//React
import { useParams } from 'react-router-dom';
import { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useEffect } from 'react';

//Bootstrap
import Button from 'react-bootstrap/Button';
import Form from 'react-bootstrap/Form';
import InputGroup from 'react-bootstrap/InputGroup';
import OverlayTrigger from 'react-bootstrap/OverlayTrigger';
import Tooltip from 'react-bootstrap/Tooltip';

//Icons
import { BsFillInfoCircleFill } from "react-icons/bs";

//Style
import s from './mint.module.css';

//Local Components
import TresNft from '../../Components/Tres-Nft/tres-nft';

// Redux actions
import { getAllVisibleCauses, POLYGON } from '../../redux/actions'

import abi from "../../Utils/Constants/abi.json";
import { ethers } from 'ethers';

export default function Mint() {
  const {container, checkContainer, info, mintDiv, counter, icon, collectionImage} = s;
  const { collectionContractAddress } = useParams();
  //Dispatch
  const dispatch = useDispatch();
  useEffect(()=> {
    dispatch(getAllVisibleCauses());
  }, [ dispatch, collectionContractAddress ]);
  const causes = useSelector(state => state.allVisibleCauses);
  const cause = causes.filter(contract => (contract.address === collectionContractAddress))[0];
  const state = false;
  const red = useSelector(state => state?.chain.network);

  const [donateAll, setDonateAll] = useState(false);
  const [nftCount, setNftCount] = useState(1);
  const [classname, setClassname] = useState("");
  const [msg, setMsg] = useState("");
  const [maxiSupply, setMaxiSupply] = useState(0);
  //const [AvailableSupply, setAvailableSupply] = useState(0);
  const [mintedSupply, setMintedSupply] = useState(0);

  //TODO INTERACTUAR CON REDUX
  const price = cause?.presale_mint_price;
  const imagesContracts = ["0x51710b84b3be56201b87bdf052c07ee9d334ddce", "0x2ead43c1d40ee4f642e9a558e781fd88e39b3209", "0x8c34e57d808a1c8a99a1a7fcc4d1ca6557c5e384"];

  const onCheck = () => {
    setDonateAll(!donateAll);
  }

  const getSupplys = async() => {
    try {
      const { ethereum } = window;
			if (ethereum) {
        const provider = new ethers.providers.Web3Provider(ethereum);
				const signer = provider.getSigner();
				const contract = new ethers.Contract(collectionContractAddress, abi.abi, signer);

        let max = await contract.maxSupply();
        let minted = await contract.totalSupply();

        console.log("mited "+minted);
        
        setMaxiSupply(max);
        setMintedSupply(minted);
      }
    } catch (error) {
      console.log(error);
    }
    
  }

  const mint = async () => {
    try {
      const { ethereum } = window;
			if (ethereum) {
				const provider = new ethers.providers.Web3Provider(ethereum);
				const signer = provider.getSigner();
				const contract = new ethers.Contract(collectionContractAddress, abi.abi, signer);

				console.log("Going to pop wallet now to pay gas...");
        let priceFinal = nftCount * price;
				let tx = await contract.mint(nftCount, {
					value: ethers.utils.parseEther(priceFinal.toString()),
				});
				// Wait for the transaction to be mined
				const receipt = await tx.wait();
				// Check if the transaction was successfully completed
				if (receipt.status === 1) {
          setClassname("alert alert-success");
          setMsg("NFT Minted!, Wait a moment to udate the data");
          setTimeout(() => {
            window.location.reload(); 
          }, 20000);
				} else {
          setClassname("alert alert-danger");
          setMsg("Transaction failed! Please try again");
				}
			}
    } catch (error) {
      console.log(error);
    }

  }
  const validaRed = () => {
    return red !== POLYGON;
  }

  const change = (number) => {
    if ((number < 0 && nftCount > 1) || (number > 0 && nftCount < 10)) {
      setNftCount(nftCount + number);
    }
  }

  useEffect(()=>{
    getSupplys();
  },[]);
  
  return(   
    <div className={container}>
      <p className="bigTitle">{cause?.name} Mint</p>
      {/* <TresNft collectionContractAddress={collectionContractAddress} causes={causes}/> */}
      <img className={collectionImage} src={`../../../causa${imagesContracts.indexOf(collectionContractAddress) + 1}.png`} alt='nft'/>
      <hr/>
      <p>Price per mint: {price} MATIC</p>
      {/* <div className={checkContainer}>
        <Form.Group className="mb-3" controlId="formBasicCheckbox">
          <Form.Check onChange={onCheck} type="checkbox" label="Donate All Profit" />
        </Form.Group>
        <OverlayTrigger
          key={"right"}
          placement={"right"}
          overlay={
            <Tooltip id={`tooltip-right`}>
              Check to give to your favorite cause the 100% profit generated by your NFT investment.
            </Tooltip>
          }
        >
        <Button className={info}><BsFillInfoCircleFill className={icon}/></Button>
        </OverlayTrigger>
      </div> */}
      
      <p>{mintedSupply + "/"  + maxiSupply} Minted </p>
      <div className={mintDiv}>
        <InputGroup className={counter}>
          <Form.Control
            value={nftCount}
            placeholder=""
            aria-label="Recipient's username with two button addons"
            disabled
          />
          <Button onClick={() => change(-1)} variant="outline-secondary">-</Button>
          <Button onClick={() => change(+1)} variant="outline-secondary">+</Button>
        </InputGroup>
        <Button onClick={mint} className="generalButton" variant="secondary" disabled={state || validaRed()}>Mint</Button>
      </div>
      <br/>
      <div className={classname}>{msg}</div>
    </div>
  )
}